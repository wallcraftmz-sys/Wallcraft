from flask import Flask, render_template, request, session, redirect, url_for
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import threading
import os
from dotenv import load_dotenv
load_dotenv()

app = Flask(____)
app.secret_key = 'wallcraft_secret_key'

# Список товаров с категориями
products = [
    {
        "id": 1,
        "category": "walls",
        "name_lv": "Šķidrie tapetes — South 941",
        "name_ru": "Жидкие обои — South 941",
        "description_lv": "Materiāls dekoratīvai sienu...",
        "description_ru": "Материал для декоративной отделки...",
        "price": 25.00,
        "image": "liquid_wallpaper.jpg"
    },
    {
        "id": 2,
        "category": "tools",
        "name_lv": "Rīku komplekts",
        "name_ru": "Набор инструментов",
        "description_lv": "Komplekts ar visu nepieciešamo",
        "description_ru": "Комплект со всем необходимым",
        "price": 15.00,
        "image": "tool.jpg"
    }
]

@app.before_request
def get_lang():
    session['lang'] = request.args.get('lang') or session.get('lang') or 'lv'

# Главная
@app.route('/')
def index():
    lang = session.get('lang')
    return render_template('index.html', lang=lang, products=products)

# Каталог с фильтрами
@app.route('/catalog')
def catalog():
    lang = session.get('lang')

    cat = request.args.get("cat")
    min_price = request.args.get("min_price")
    max_price = request.args.get("max_price")

    filtered = products

    if cat:
        filtered = [p for p in filtered if p["category"] == cat]
    if min_price:
        try:
            filtered = [p for p in filtered if p["price"] >= float(min_price)]
        except:
            pass
    if max_price:
        try:
            filtered = [p for p in filtered if p["price"] <= float(max_price)]
        except:
            pass

    return render_template("catalog.html", lang=lang, products=filtered)

# Страница товара
@app.route('/product/<int:id>')
def product(id):
    lang = session.get('lang')
    product_item = next((p for p in products if p['id'] == id), None)
    return render_template('product.html', lang=lang, product=product_item)

# Добавить в корзину
@app.route("/add_to_cart/<int:product_id>")
def add_to_cart(product_id):
    cart = session.get("cart", {})
    cart[str(product_id)] = cart.get(str(product_id), 0) + 1
    session["cart"] = cart
    return redirect(url_for("cart"))

# Корзина
@app.route("/cart")
def cart():
    cart = session.get("cart", {})
    cart_items = []
    total = 0

    for pid, qty in cart.items():
        prod = next((p for p in products if p["id"] == int(pid)), None)
        if prod:
            cart_items.append({"product": prod, "qty": qty})
            total += prod["price"] * qty

    return render_template("cart.html", cart_items=cart_items, total=total)

# Форма заказа
@app.route("/order", methods=["GET", "POST"])
def order():
    if request.method == "POST":
        name = request.form.get("name")
        contact = request.form.get("contact")

        # Асинхронная отправка
        def send_email(name, contact):
            sender_email = os.environ.get("WALLCRAFT_EMAIL")
            receiver_email = os.environ.get("WALLCRAFT_EMAIL")
            app_password = os.environ.get("WALLCRAFT_APP_PASSWORD")

            subject = "Новая заявка с сайта"
            body = f"Имя: {name}\nКонтакт: {contact}"

            message = MIMEMultipart()
            message["From"] = sender_email
            message["To"] = receiver_email
            message["Subject"] = subject
            message.attach(MIMEText(body, "plain"))

            try:
                with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
                    server.login(sender_email, app_password)
                    server.sendmail(sender_email, receiver_email, message.as_string())
                print("Письмо отправлено!")
            except Exception as e:
                print("Ошибка:", e)

        threading.Thread(target=send_email, args=(name, contact)).start()

        return render_template("order.html", success=True)

    return render_template("order.html")
# ================= Админ‑панель ↓ =================

from functools import wraps

# Логин/пароль для админа (можно хранить в переменных окружения)
ADMIN_LOGIN = os.environ.get("ADMIN_LOGIN", "admin")
ADMIN_PASSWORD = os.environ.get("ADMIN_PASSWORD", "wallcraft123")

# Декоратор для защиты админ‑панели
def admin_required(f):
    @wraps(f)
    def wrapped(*args, **kwargs):
        if session.get("is_admin"):
            return f(*args, **kwargs)
        return redirect(url_for("admin_login"))
    return wrapped

# Маршрут входа для администратора
@app.route("/admin/login", methods=["GET", "POST"])
def admin_login():
    if request.method == "POST":
        login = request.form.get("login")
        password = request.form.get("password")
        # Проверяем логин и пароль
        if login == ADMIN_LOGIN and password == ADMIN_PASSWORD:
            session["is_admin"] = True
            return redirect("/admin")
        # Неверные данные
        return render_template("admin_login.html", error="Неверный логин или пароль")
    return render_template("admin_login.html")

# Маршрут выхода
@app.route("/admin/logout")
def admin_logout():
    session.pop("is_admin", None)
    return redirect("/admin/login")

# Защищённая админ‑панель
@app.route("/admin")
@admin_required
def admin_panel():
    # Показываем список заказов из базы
    conn = sqlite3.connect("orders.db")
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM orders")
    orders = cursor.fetchall()
    conn.close()
    return render_template("admin.html", orders=orders)

# ================= Админ‑панель ↑ =================
